#!/usr/bin/env node
import e from"node:path";import t from"node:fs";import s from"yargs";import{hideBin as r}from"yargs/helpers";import n from"express";import i from"node:http";import o from"node:https";import{randomUUID as c}from"node:crypto";import{EventEmitter as a}from"node:events";import l from"node:url";import{WebSocketServer as d}from"ws";import p from"cors";function u(e){return e&&e.__esModule?e.default:e}var h;h=JSON.parse('{"name":"peer","version":"0.0.0-development","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS server component","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs-server/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs-server"},"license":"MIT","contributors":[],"type":"module","exports":{".":{"import":{"types":"./dist/peer.d.ts","default":"./dist/module.mjs"},"require":{"types":"./dist/peer.d.ts","default":"./dist/index.cjs"}}},"main":"dist/index.cjs","module":"dist/module.mjs","source":"src/index.ts","binary":"dist/bin/peerjs.js","types":"dist/peer.d.ts","bin":{"peerjs":"dist/bin/peerjs.js"},"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/"],"engines":{"node":">=14"},"targets":{"binary":{"source":"bin/peerjs.ts"},"main":{},"module":{}},"scripts":{"format":"prettier --write .","build":"parcel build","lint":"eslint --ext .js,.ts . && npm run check","check":"tsc --noEmit","test":"npm run lint && jest","coverage":"jest --coverage","start":"node dist/bin/peerjs.js --port ${PORT:=9000}","dev":"nodemon --watch src -e ts --exec \'npm run build && npm run start\'","semantic-release":"semantic-release"},"dependencies":{"@types/express":"^4.17.3","@types/ws":"^7.2.3 || ^8.0.0","cors":"^2.8.5","express":"^4.17.1","node-fetch":"^3.3.0","ws":"^7.2.3 || ^8.0.0","yargs":"^17.6.2"},"devDependencies":{"@codedependant/semantic-release-docker":"^4.3.0","@parcel/packager-ts":"^2.8.2","@parcel/transformer-typescript-types":"^2.8.2","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@swc/core":"^1.3.35","@swc/jest":"^0.2.24","@tsconfig/node16-strictest-esm":"^1.0.3","@types/cors":"^2.8.6","@types/jest":"^29.4.0","@types/node":"^14.18.33","@types/yargs":"^17.0.19","@typescript-eslint/eslint-plugin":"^5.0.0","@typescript-eslint/parser":"^5.0.0","eslint":"^8.0.0","jest":"^29.4.2","mock-socket":"^9.1.5","parcel":"^2.8.2","prettier":"^2.8.4","semantic-release":"^20.0.0","typescript":"^4.1.2"}}');var g={host:"::",port:9e3,expire_timeout:5e3,alive_timeout:6e4,key:"peerjs",path:"/",concurrent_limit:5e3,allow_discovery:!1,proxied:!1,cleanup_out_msgs:1e3,corsOptions:{origin:!0}};class m{lastReadAt=(new Date).getTime();messages=[];getLastReadAt(){return this.lastReadAt}addMessage(e){this.messages.push(e)}readMessage(){if(this.messages.length>0)return this.lastReadAt=(new Date).getTime(),this.messages.shift()}getMessages(){return this.messages}}class y{clients=new Map;messageQueues=new Map;getClientsIds(){return[...this.clients.keys()]}getClientById(e){return this.clients.get(e)}getClientsIdsWithQueue(){return[...this.messageQueues.keys()]}setClient(e,t){this.clients.set(t,e)}removeClientById(e){return!!this.getClientById(e)&&(this.clients.delete(e),!0)}getMessageQueueById(e){return this.messageQueues.get(e)}addMessageToQueue(e,t){this.getMessageQueueById(e)||this.messageQueues.set(e,new m),this.getMessageQueueById(e)?.addMessage(t)}clearMessageQueue(e){this.messageQueues.delete(e)}generateClientId(e){const t=e||c;let s=t();for(;this.getClientById(s);)s=t();return s}}class f{timeoutId=null;constructor({realm:e,config:t,checkInterval:s=300,onClose:r}){this.realm=e,this.config=t,this.onClose=r,this.checkInterval=s}start(){this.timeoutId&&clearTimeout(this.timeoutId),this.timeoutId=setTimeout((()=>{this.checkConnections(),this.timeoutId=null,this.start()}),this.checkInterval)}stop(){this.timeoutId&&(clearTimeout(this.timeoutId),this.timeoutId=null)}checkConnections(){const e=this.realm.getClientsIds(),t=(new Date).getTime(),{alive_timeout:s}=this.config;for(const r of e){const e=this.realm.getClientById(r);if(!e)continue;if(!(t-e.getLastPing()<s))try{e.getSocket()?.close()}finally{this.realm.clearMessageQueue(r),this.realm.removeClientById(r),e.setSocket(null),this.onClose?.(e)}}}}let I;var E;let v;var k;(E=I||(I={})).INVALID_KEY="Invalid key provided",E.INVALID_TOKEN="Invalid token provided",E.INVALID_WS_PARAMETERS="No id, token, or key supplied to websocket server",E.CONNECTION_LIMIT_EXCEED="Server has reached its concurrent user limit",(k=v||(v={})).OPEN="OPEN",k.LEAVE="LEAVE",k.CANDIDATE="CANDIDATE",k.OFFER="OFFER",k.ANSWER="ANSWER",k.EXPIRE="EXPIRE",k.HEARTBEAT="HEARTBEAT",k.ID_TAKEN="ID-TAKEN",k.ERROR="ERROR";class S{timeoutId=null;constructor({realm:e,config:t,messageHandler:s}){this.realm=e,this.config=t,this.messageHandler=s}startMessagesExpiration(){this.timeoutId&&clearTimeout(this.timeoutId),this.timeoutId=setTimeout((()=>{this.pruneOutstanding(),this.timeoutId=null,this.startMessagesExpiration()}),this.config.cleanup_out_msgs)}stopMessagesExpiration(){this.timeoutId&&(clearTimeout(this.timeoutId),this.timeoutId=null)}pruneOutstanding(){const e=this.realm.getClientsIdsWithQueue(),t=(new Date).getTime(),s=this.config.expire_timeout,r={};for(const n of e){const e=this.realm.getMessageQueueById(n);if(!e)continue;if(t-e.getLastReadAt()<s)continue;const i=e.getMessages();for(const e of i){const t=`${e.src}_${e.dst}`;r[t]||(this.messageHandler.handle(void 0,{type:v.EXPIRE,src:e.dst,dst:e.src}),r[t]=!0)}this.realm.clearMessageQueue(n)}}}class R{socket=null;lastPing=(new Date).getTime();constructor({id:e,token:t}){this.id=e,this.token=t}getId(){return this.id}getToken(){return this.token}getSocket(){return this.socket}setSocket(e){this.socket=e}getLastPing(){return this.lastPing}setLastPing(e){this.lastPing=e}send(e){this.socket?.send(JSON.stringify(e))}}class C extends a{constructor({server:e,realm:t,config:s}){super(),this.setMaxListeners(0),this.realm=t,this.config=s;const r=this.config.path;this.path=`${r}${r.endsWith("/")?"":"/"}peerjs`;const n={path:this.path,server:e};this.socketServer=s.createWebSocketServer?s.createWebSocketServer(n):new d(n),this.socketServer.on("connection",((e,t)=>this._onSocketConnection(e,t))),this.socketServer.on("error",(e=>this._onSocketError(e)))}_onSocketConnection(e,t){e.on("error",(e=>this._onSocketError(e)));const{query:s={}}=l.parse(t.url??"",!0),{id:r,token:n,key:i}=s;if(!r||!n||!i)return this._sendErrorAndClose(e,I.INVALID_WS_PARAMETERS);if(i!==this.config.key)return this._sendErrorAndClose(e,I.INVALID_KEY);const o=this.realm.getClientById(r);if(o)return n!==o.getToken()?(e.send(JSON.stringify({type:v.ID_TAKEN,payload:{msg:"ID is taken"}})),e.close()):this._configureWS(e,o);this._registerClient({socket:e,id:r,token:n})}_onSocketError(e){this.emit("error",e)}_registerClient({socket:e,id:t,token:s}){if(this.realm.getClientsIds().length>=this.config.concurrent_limit)return this._sendErrorAndClose(e,I.CONNECTION_LIMIT_EXCEED);const r=new R({id:t,token:s});this.realm.setClient(r,t),e.send(JSON.stringify({type:v.OPEN})),this._configureWS(e,r)}_configureWS(e,t){t.setSocket(e),e.on("close",(()=>{t.getSocket()===e&&(this.realm.removeClientById(t.getId()),this.emit("close",t))})),e.on("message",(e=>{try{const s=JSON.parse(e.toString());s.src=t.getId(),this.emit("message",t,s)}catch(e){this.emit("error",e)}})),this.emit("connection",t)}_sendErrorAndClose(e,t){e.send(JSON.stringify({type:v.ERROR,payload:{msg:t}})),e.close()}}const _=e=>{if(e){const t=(new Date).getTime();e.setLastPing(t)}return!0},O=({realm:e})=>{const t=(s,r)=>{const n=r.type,i=r.src,o=r.dst,c=e.getClientById(o);if(c){const n=c.getSocket();try{if(!n)throw new Error("Peer dead");{const e=JSON.stringify(r);n.send(e)}}catch(r){n?n.close():e.removeClientById(c.getId()),t(s,{type:v.LEAVE,src:o,dst:i})}}else{![v.LEAVE,v.EXPIRE].includes(n)&&o?e.addMessageToQueue(o,r):n!==v.LEAVE||o||e.removeClientById(i)}return!0};return t};class A{handlers=new Map;registerHandler(e,t){this.handlers.has(e)||this.handlers.set(e,t)}handle(e,t){const{type:s}=t,r=this.handlers.get(s);return!!r&&r(e,t)}}class b{constructor(e,t=new A){this.handlersRegistry=t;const s=O({realm:e}),r=_,n=(e,{type:t,src:r,dst:n,payload:i})=>s(e,{type:t,src:r,dst:n,payload:i});this.handlersRegistry.registerHandler(v.HEARTBEAT,((e,t)=>r(e,t))),this.handlersRegistry.registerHandler(v.OFFER,n),this.handlersRegistry.registerHandler(v.ANSWER,n),this.handlersRegistry.registerHandler(v.CANDIDATE,n),this.handlersRegistry.registerHandler(v.LEAVE,n),this.handlersRegistry.registerHandler(v.EXPIRE,n)}handle(e,t){return this.handlersRegistry.handle(e,t)}}var T;T=JSON.parse('{"name":"PeerJS Server","description":"A server side element to broker connections between PeerJS clients.","website":"https://peerjs.com/"}');var w=({config:e,realm:t})=>{const s=n.Router();return s.get("/id",((s,r)=>{r.contentType("html"),r.send(t.generateClientId(e.generateClientId))})),s.get("/peers",((s,r)=>{if(e.allow_discovery){const e=t.getClientsIds();return r.send(e)}return r.sendStatus(401)})),s};const N=({config:e,realm:t,corsOptions:s})=>{const r=n.Router();return r.use(p(s)),r.get("/",((e,t)=>{t.send(u(T))})),r.use("/:key",w({config:e,realm:t})),r},M=({app:t,server:s,options:r})=>{const n=r,i=new y,o=new b(i),c=N({config:n,realm:i,corsOptions:r.corsOptions}),a=new S({realm:i,config:n,messageHandler:o}),l=new f({realm:i,config:n,onClose:e=>{t.emit("disconnect",e)}});t.use(r.path,c);const d={...n,path:e.posix.join(t.path(),r.path,"/")},p=new C({server:s,realm:i,config:d});p.on("connection",(e=>{const s=i.getMessageQueueById(e.getId());if(s){let t;for(;t=s.readMessage();)o.handle(e,t);i.clearMessageQueue(e.getId())}t.emit("connection",e)})),p.on("message",((e,s)=>{t.emit("message",e,s),o.handle(e,s)})),p.on("close",(e=>{t.emit("disconnect",e)})),p.on("error",(e=>{t.emit("error",e)})),a.startMessagesExpiration(),l.start()};const P=s(r(process.argv)),x=!!process.env.PORT,j=P.usage("Usage: $0").wrap(Math.min(98,P.terminalWidth())).options({expire_timeout:{demandOption:!1,alias:"t",describe:"timeout (milliseconds)",default:5e3},concurrent_limit:{demandOption:!1,alias:"c",describe:"concurrent limit",default:5e3},alive_timeout:{demandOption:!1,describe:"broken connection check timeout (milliseconds)",default:6e4},key:{demandOption:!1,alias:"k",describe:"connection key",default:"peerjs"},sslkey:{type:"string",demandOption:!1,describe:"path to SSL key"},sslcert:{type:"string",demandOption:!1,describe:"path to SSL certificate"},host:{type:"string",demandOption:!1,alias:"H",describe:"host"},port:{type:"number",demandOption:!x,alias:"p",describe:"port"},path:{type:"string",demandOption:!1,describe:"custom path",default:process.env.PEERSERVER_PATH||"/"},allow_discovery:{type:"boolean",demandOption:!1,describe:"allow discovery of peers"},proxied:{type:"boolean",demandOption:!1,describe:"Set true if PeerServer stays behind a reverse proxy",default:!1},cors:{type:"string",array:!0,describe:"Set the list of CORS origins"}}).boolean("allow_discovery").parseSync();j.port||(j.port=parseInt(process.env.PORT)),j.cors&&(j.corsOptions={origin:j.cors}),process.on("uncaughtException",(function(e){console.error("Error: "+e)})),(j.sslkey||j.sslcert)&&(j.sslkey&&j.sslcert?j.ssl={key:t.readFileSync(e.resolve(j.sslkey)),cert:t.readFileSync(e.resolve(j.sslcert))}:(console.error("Warning: PeerServer will not run because either the key or the certificate has not been provided."),process.exit(1)));const D=j.path,L=function(e={},t){const s=n();let r={...g,...e};const c=r.port,a=r.host;let l;const{ssl:d,...p}=r;d&&Object.keys(d).length?(l=o.createServer(d,s),r=p):l=i.createServer(s);const u=function(e,t){const s=n(),r={...g,...t};return r.proxied&&s.set("trust proxy","false"!==r.proxied&&!!r.proxied),s.on("mount",(()=>{if(!e)throw new Error("Server is not passed to constructor - can't start PeerServer");M({app:s,server:e,options:r})})),s}(l,r);return s.use(u),l.listen(c,a,(()=>t?.(l))),u}(j,(e=>{const{address:t,port:s}=e.address();console.log("Started PeerServer on %s, port: %s, path: %s (v. %s)",t,s,D||"/",h.version);const r=()=>{e.close((()=>{console.log("Http server closed."),process.exit(0)}))};process.on("SIGINT",r),process.on("SIGTERM",r)}));L.on("connection",(e=>{console.log(`Client connected: ${e.getId()}`)})),L.on("disconnect",(e=>{console.log(`Client disconnected: ${e.getId()}`)}));
//# sourceMappingURL=peerjs.js.map
