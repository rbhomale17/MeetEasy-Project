{"mappings":"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","sources":["package.json","src/config/index.ts","src/models/messageQueue.ts","src/models/realm.ts","src/services/checkBrokenConnections/index.ts","src/enums.ts","src/services/messagesExpire/index.ts","src/models/client.ts","src/services/webSocketServer/index.ts","src/messageHandler/handlers/heartbeat/index.ts","src/messageHandler/handlers/transmission/index.ts","src/messageHandler/handlersRegistry.ts","src/messageHandler/index.ts","app.json","src/api/v1/public/index.ts","src/api/index.ts","src/instance.ts","bin/peerjs.ts","src/index.ts"],"sourcesContent":["{\n\t\"name\": \"peer\",\n\t\"version\": \"0.0.0-development\",\n\t\"keywords\": [\n\t\t\"peerjs\",\n\t\t\"webrtc\",\n\t\t\"p2p\",\n\t\t\"rtc\"\n\t],\n\t\"description\": \"PeerJS server component\",\n\t\"homepage\": \"https://peerjs.com\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/peers/peerjs-server/issues\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"https://github.com/peers/peerjs-server\"\n\t},\n\t\"license\": \"MIT\",\n\t\"contributors\": [],\n\t\"type\": \"module\",\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"import\": {\n\t\t\t\t\"types\": \"./dist/peer.d.ts\",\n\t\t\t\t\"default\": \"./dist/module.mjs\"\n\t\t\t},\n\t\t\t\"require\": {\n\t\t\t\t\"types\": \"./dist/peer.d.ts\",\n\t\t\t\t\"default\": \"./dist/index.cjs\"\n\t\t\t}\n\t\t}\n\t},\n\t\"main\": \"dist/index.cjs\",\n\t\"module\": \"dist/module.mjs\",\n\t\"source\": \"src/index.ts\",\n\t\"binary\": \"dist/bin/peerjs.js\",\n\t\"types\": \"dist/peer.d.ts\",\n\t\"bin\": {\n\t\t\"peerjs\": \"dist/bin/peerjs.js\"\n\t},\n\t\"funding\": {\n\t\t\"type\": \"opencollective\",\n\t\t\"url\": \"https://opencollective.com/peer\"\n\t},\n\t\"collective\": {\n\t\t\"type\": \"opencollective\",\n\t\t\"url\": \"https://opencollective.com/peer\"\n\t},\n\t\"files\": [\n\t\t\"dist/\"\n\t],\n\t\"engines\": {\n\t\t\"node\": \">=14\"\n\t},\n\t\"targets\": {\n\t\t\"binary\": {\n\t\t\t\"source\": \"bin/peerjs.ts\"\n\t\t},\n\t\t\"main\": {},\n\t\t\"module\": {}\n\t},\n\t\"scripts\": {\n\t\t\"format\": \"prettier --write .\",\n\t\t\"build\": \"parcel build\",\n\t\t\"lint\": \"eslint --ext .js,.ts . && npm run check\",\n\t\t\"check\": \"tsc --noEmit\",\n\t\t\"test\": \"npm run lint && jest\",\n\t\t\"coverage\": \"jest --coverage\",\n\t\t\"start\": \"node dist/bin/peerjs.js --port ${PORT:=9000}\",\n\t\t\"dev\": \"nodemon --watch src -e ts --exec 'npm run build && npm run start'\",\n\t\t\"semantic-release\": \"semantic-release\"\n\t},\n\t\"dependencies\": {\n\t\t\"@types/express\": \"^4.17.3\",\n\t\t\"@types/ws\": \"^7.2.3 || ^8.0.0\",\n\t\t\"cors\": \"^2.8.5\",\n\t\t\"express\": \"^4.17.1\",\n\t\t\"node-fetch\": \"^3.3.0\",\n\t\t\"ws\": \"^7.2.3 || ^8.0.0\",\n\t\t\"yargs\": \"^17.6.2\"\n\t},\n\t\"devDependencies\": {\n\t\t\"@codedependant/semantic-release-docker\": \"^4.3.0\",\n\t\t\"@parcel/packager-ts\": \"^2.8.2\",\n\t\t\"@parcel/transformer-typescript-types\": \"^2.8.2\",\n\t\t\"@semantic-release/changelog\": \"^6.0.1\",\n\t\t\"@semantic-release/git\": \"^10.0.1\",\n\t\t\"@swc/core\": \"^1.3.35\",\n\t\t\"@swc/jest\": \"^0.2.24\",\n\t\t\"@tsconfig/node16-strictest-esm\": \"^1.0.3\",\n\t\t\"@types/cors\": \"^2.8.6\",\n\t\t\"@types/jest\": \"^29.4.0\",\n\t\t\"@types/node\": \"^14.18.33\",\n\t\t\"@types/yargs\": \"^17.0.19\",\n\t\t\"@typescript-eslint/eslint-plugin\": \"^5.0.0\",\n\t\t\"@typescript-eslint/parser\": \"^5.0.0\",\n\t\t\"eslint\": \"^8.0.0\",\n\t\t\"jest\": \"^29.4.2\",\n\t\t\"mock-socket\": \"^9.1.5\",\n\t\t\"parcel\": \"^2.8.2\",\n\t\t\"prettier\": \"^2.8.4\",\n\t\t\"semantic-release\": \"^20.0.0\",\n\t\t\"typescript\": \"^4.1.2\"\n\t}\n}\n","import type { WebSocketServer, ServerOptions } from \"ws\";\nimport type { CorsOptions } from \"cors\";\n\nexport interface IConfig {\n\treadonly host: string;\n\treadonly port: number;\n\treadonly expire_timeout: number;\n\treadonly alive_timeout: number;\n\treadonly key: string;\n\treadonly path: string;\n\treadonly concurrent_limit: number;\n\treadonly allow_discovery: boolean;\n\treadonly proxied: boolean | string;\n\treadonly cleanup_out_msgs: number;\n\treadonly ssl?: {\n\t\tkey: string;\n\t\tcert: string;\n\t};\n\treadonly generateClientId?: () => string;\n\treadonly createWebSocketServer?: (options: ServerOptions) => WebSocketServer;\n\treadonly corsOptions: CorsOptions;\n}\n\nconst defaultConfig: IConfig = {\n\thost: \"::\",\n\tport: 9000,\n\texpire_timeout: 5000,\n\talive_timeout: 60000,\n\tkey: \"peerjs\",\n\tpath: \"/\",\n\tconcurrent_limit: 5000,\n\tallow_discovery: false,\n\tproxied: false,\n\tcleanup_out_msgs: 1000,\n\tcorsOptions: { origin: true },\n};\n\nexport default defaultConfig;\n","import type { IMessage } from \"./message\";\n\nexport interface IMessageQueue {\n\tgetLastReadAt(): number;\n\n\taddMessage(message: IMessage): void;\n\n\treadMessage(): IMessage | undefined;\n\n\tgetMessages(): IMessage[];\n}\n\nexport class MessageQueue implements IMessageQueue {\n\tprivate lastReadAt: number = new Date().getTime();\n\tprivate readonly messages: IMessage[] = [];\n\n\tpublic getLastReadAt(): number {\n\t\treturn this.lastReadAt;\n\t}\n\n\tpublic addMessage(message: IMessage): void {\n\t\tthis.messages.push(message);\n\t}\n\n\tpublic readMessage(): IMessage | undefined {\n\t\tif (this.messages.length > 0) {\n\t\t\tthis.lastReadAt = new Date().getTime();\n\t\t\treturn this.messages.shift();\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tpublic getMessages(): IMessage[] {\n\t\treturn this.messages;\n\t}\n}\n","import type { IMessageQueue } from \"./messageQueue\";\nimport { MessageQueue } from \"./messageQueue\";\nimport { randomUUID } from \"node:crypto\";\nimport type { IClient } from \"./client\";\nimport type { IMessage } from \"./message\";\n\nexport interface IRealm {\n\tgetClientsIds(): string[];\n\n\tgetClientById(clientId: string): IClient | undefined;\n\n\tgetClientsIdsWithQueue(): string[];\n\n\tsetClient(client: IClient, id: string): void;\n\n\tremoveClientById(id: string): boolean;\n\n\tgetMessageQueueById(id: string): IMessageQueue | undefined;\n\n\taddMessageToQueue(id: string, message: IMessage): void;\n\n\tclearMessageQueue(id: string): void;\n\n\tgenerateClientId(generateClientId?: () => string): string;\n}\n\nexport class Realm implements IRealm {\n\tprivate readonly clients: Map<string, IClient> = new Map();\n\tprivate readonly messageQueues: Map<string, IMessageQueue> = new Map();\n\n\tpublic getClientsIds(): string[] {\n\t\treturn [...this.clients.keys()];\n\t}\n\n\tpublic getClientById(clientId: string): IClient | undefined {\n\t\treturn this.clients.get(clientId);\n\t}\n\n\tpublic getClientsIdsWithQueue(): string[] {\n\t\treturn [...this.messageQueues.keys()];\n\t}\n\n\tpublic setClient(client: IClient, id: string): void {\n\t\tthis.clients.set(id, client);\n\t}\n\n\tpublic removeClientById(id: string): boolean {\n\t\tconst client = this.getClientById(id);\n\n\t\tif (!client) return false;\n\n\t\tthis.clients.delete(id);\n\n\t\treturn true;\n\t}\n\n\tpublic getMessageQueueById(id: string): IMessageQueue | undefined {\n\t\treturn this.messageQueues.get(id);\n\t}\n\n\tpublic addMessageToQueue(id: string, message: IMessage): void {\n\t\tif (!this.getMessageQueueById(id)) {\n\t\t\tthis.messageQueues.set(id, new MessageQueue());\n\t\t}\n\n\t\tthis.getMessageQueueById(id)?.addMessage(message);\n\t}\n\n\tpublic clearMessageQueue(id: string): void {\n\t\tthis.messageQueues.delete(id);\n\t}\n\n\tpublic generateClientId(generateClientId?: () => string): string {\n\t\tconst generateId = generateClientId ? generateClientId : randomUUID;\n\n\t\tlet clientId = generateId();\n\n\t\twhile (this.getClientById(clientId)) {\n\t\t\tclientId = generateId();\n\t\t}\n\n\t\treturn clientId;\n\t}\n}\n","import type { IConfig } from \"../../config\";\nimport type { IClient } from \"../../models/client\";\nimport type { IRealm } from \"../../models/realm\";\n\nconst DEFAULT_CHECK_INTERVAL = 300;\n\ntype CustomConfig = Pick<IConfig, \"alive_timeout\">;\n\nexport class CheckBrokenConnections {\n\tpublic readonly checkInterval: number;\n\tprivate timeoutId: NodeJS.Timeout | null = null;\n\tprivate readonly realm: IRealm;\n\tprivate readonly config: CustomConfig;\n\tprivate readonly onClose?: (client: IClient) => void;\n\n\tconstructor({\n\t\trealm,\n\t\tconfig,\n\t\tcheckInterval = DEFAULT_CHECK_INTERVAL,\n\t\tonClose,\n\t}: {\n\t\trealm: IRealm;\n\t\tconfig: CustomConfig;\n\t\tcheckInterval?: number;\n\t\tonClose?: (client: IClient) => void;\n\t}) {\n\t\tthis.realm = realm;\n\t\tthis.config = config;\n\t\tthis.onClose = onClose;\n\t\tthis.checkInterval = checkInterval;\n\t}\n\n\tpublic start(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t}\n\n\t\tthis.timeoutId = setTimeout(() => {\n\t\t\tthis.checkConnections();\n\n\t\t\tthis.timeoutId = null;\n\n\t\t\tthis.start();\n\t\t}, this.checkInterval);\n\t}\n\n\tpublic stop(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t\tthis.timeoutId = null;\n\t\t}\n\t}\n\n\tprivate checkConnections(): void {\n\t\tconst clientsIds = this.realm.getClientsIds();\n\n\t\tconst now = new Date().getTime();\n\t\tconst { alive_timeout: aliveTimeout } = this.config;\n\n\t\tfor (const clientId of clientsIds) {\n\t\t\tconst client = this.realm.getClientById(clientId);\n\n\t\t\tif (!client) continue;\n\n\t\t\tconst timeSinceLastPing = now - client.getLastPing();\n\n\t\t\tif (timeSinceLastPing < aliveTimeout) continue;\n\n\t\t\ttry {\n\t\t\t\tclient.getSocket()?.close();\n\t\t\t} finally {\n\t\t\t\tthis.realm.clearMessageQueue(clientId);\n\t\t\t\tthis.realm.removeClientById(clientId);\n\n\t\t\t\tclient.setSocket(null);\n\n\t\t\t\tthis.onClose?.(client);\n\t\t\t}\n\t\t}\n\t}\n}\n","export enum Errors {\n\tINVALID_KEY = \"Invalid key provided\",\n\tINVALID_TOKEN = \"Invalid token provided\",\n\tINVALID_WS_PARAMETERS = \"No id, token, or key supplied to websocket server\",\n\tCONNECTION_LIMIT_EXCEED = \"Server has reached its concurrent user limit\",\n}\n\nexport enum MessageType {\n\tOPEN = \"OPEN\",\n\tLEAVE = \"LEAVE\",\n\tCANDIDATE = \"CANDIDATE\",\n\tOFFER = \"OFFER\",\n\tANSWER = \"ANSWER\",\n\tEXPIRE = \"EXPIRE\",\n\tHEARTBEAT = \"HEARTBEAT\",\n\tID_TAKEN = \"ID-TAKEN\",\n\tERROR = \"ERROR\",\n}\n","import { MessageType } from \"../../enums\";\nimport type { IConfig } from \"../../config\";\nimport type { IMessageHandler } from \"../../messageHandler\";\nimport type { IRealm } from \"../../models/realm\";\n\nexport interface IMessagesExpire {\n\tstartMessagesExpiration(): void;\n\tstopMessagesExpiration(): void;\n}\n\ntype CustomConfig = Pick<IConfig, \"cleanup_out_msgs\" | \"expire_timeout\">;\n\nexport class MessagesExpire implements IMessagesExpire {\n\tprivate readonly realm: IRealm;\n\tprivate readonly config: CustomConfig;\n\tprivate readonly messageHandler: IMessageHandler;\n\n\tprivate timeoutId: NodeJS.Timeout | null = null;\n\n\tconstructor({\n\t\trealm,\n\t\tconfig,\n\t\tmessageHandler,\n\t}: {\n\t\trealm: IRealm;\n\t\tconfig: CustomConfig;\n\t\tmessageHandler: IMessageHandler;\n\t}) {\n\t\tthis.realm = realm;\n\t\tthis.config = config;\n\t\tthis.messageHandler = messageHandler;\n\t}\n\n\tpublic startMessagesExpiration(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t}\n\n\t\t// Clean up outstanding messages\n\t\tthis.timeoutId = setTimeout(() => {\n\t\t\tthis.pruneOutstanding();\n\n\t\t\tthis.timeoutId = null;\n\n\t\t\tthis.startMessagesExpiration();\n\t\t}, this.config.cleanup_out_msgs);\n\t}\n\n\tpublic stopMessagesExpiration(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t\tthis.timeoutId = null;\n\t\t}\n\t}\n\n\tprivate pruneOutstanding(): void {\n\t\tconst destinationClientsIds = this.realm.getClientsIdsWithQueue();\n\n\t\tconst now = new Date().getTime();\n\t\tconst maxDiff = this.config.expire_timeout;\n\n\t\tconst seen: Record<string, boolean> = {};\n\n\t\tfor (const destinationClientId of destinationClientsIds) {\n\t\t\tconst messageQueue = this.realm.getMessageQueueById(destinationClientId);\n\n\t\t\tif (!messageQueue) continue;\n\n\t\t\tconst lastReadDiff = now - messageQueue.getLastReadAt();\n\n\t\t\tif (lastReadDiff < maxDiff) continue;\n\n\t\t\tconst messages = messageQueue.getMessages();\n\n\t\t\tfor (const message of messages) {\n\t\t\t\tconst seenKey = `${message.src}_${message.dst}`;\n\n\t\t\t\tif (!seen[seenKey]) {\n\t\t\t\t\tthis.messageHandler.handle(undefined, {\n\t\t\t\t\t\ttype: MessageType.EXPIRE,\n\t\t\t\t\t\tsrc: message.dst,\n\t\t\t\t\t\tdst: message.src,\n\t\t\t\t\t});\n\n\t\t\t\t\tseen[seenKey] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.realm.clearMessageQueue(destinationClientId);\n\t\t}\n\t}\n}\n","import type WebSocket from \"ws\";\n\nexport interface IClient {\n\tgetId(): string;\n\n\tgetToken(): string;\n\n\tgetSocket(): WebSocket | null;\n\n\tsetSocket(socket: WebSocket | null): void;\n\n\tgetLastPing(): number;\n\n\tsetLastPing(lastPing: number): void;\n\n\tsend<T>(data: T): void;\n}\n\nexport class Client implements IClient {\n\tprivate readonly id: string;\n\tprivate readonly token: string;\n\tprivate socket: WebSocket | null = null;\n\tprivate lastPing: number = new Date().getTime();\n\n\tconstructor({ id, token }: { id: string; token: string }) {\n\t\tthis.id = id;\n\t\tthis.token = token;\n\t}\n\n\tpublic getId(): string {\n\t\treturn this.id;\n\t}\n\n\tpublic getToken(): string {\n\t\treturn this.token;\n\t}\n\n\tpublic getSocket(): WebSocket | null {\n\t\treturn this.socket;\n\t}\n\n\tpublic setSocket(socket: WebSocket | null): void {\n\t\tthis.socket = socket;\n\t}\n\n\tpublic getLastPing(): number {\n\t\treturn this.lastPing;\n\t}\n\n\tpublic setLastPing(lastPing: number): void {\n\t\tthis.lastPing = lastPing;\n\t}\n\n\tpublic send<T>(data: T): void {\n\t\tthis.socket?.send(JSON.stringify(data));\n\t}\n}\n","import { EventEmitter } from \"node:events\";\nimport type { IncomingMessage } from \"node:http\";\nimport url from \"node:url\";\nimport type WebSocket from \"ws\";\nimport { Errors, MessageType } from \"../../enums\";\nimport type { IClient } from \"../../models/client\";\nimport { Client } from \"../../models/client\";\nimport type { IConfig } from \"../../config\";\nimport type { IRealm } from \"../../models/realm\";\nimport { WebSocketServer as Server } from \"ws\";\nimport type { Server as HttpServer } from \"node:http\";\nimport type { Server as HttpsServer } from \"node:https\";\n\nexport interface IWebSocketServer extends EventEmitter {\n\treadonly path: string;\n}\n\ninterface IAuthParams {\n\tid?: string;\n\ttoken?: string;\n\tkey?: string;\n}\n\ntype CustomConfig = Pick<\n\tIConfig,\n\t\"path\" | \"key\" | \"concurrent_limit\" | \"createWebSocketServer\"\n>;\n\nconst WS_PATH = \"peerjs\";\n\nexport class WebSocketServer extends EventEmitter implements IWebSocketServer {\n\tpublic readonly path: string;\n\tprivate readonly realm: IRealm;\n\tprivate readonly config: CustomConfig;\n\tpublic readonly socketServer: Server;\n\n\tconstructor({\n\t\tserver,\n\t\trealm,\n\t\tconfig,\n\t}: {\n\t\tserver: HttpServer | HttpsServer;\n\t\trealm: IRealm;\n\t\tconfig: CustomConfig;\n\t}) {\n\t\tsuper();\n\n\t\tthis.setMaxListeners(0);\n\n\t\tthis.realm = realm;\n\t\tthis.config = config;\n\n\t\tconst path = this.config.path;\n\t\tthis.path = `${path}${path.endsWith(\"/\") ? \"\" : \"/\"}${WS_PATH}`;\n\n\t\tconst options: WebSocket.ServerOptions = {\n\t\t\tpath: this.path,\n\t\t\tserver,\n\t\t};\n\n\t\tthis.socketServer = config.createWebSocketServer\n\t\t\t? config.createWebSocketServer(options)\n\t\t\t: new Server(options);\n\n\t\tthis.socketServer.on(\"connection\", (socket, req) =>\n\t\t\tthis._onSocketConnection(socket, req),\n\t\t);\n\t\tthis.socketServer.on(\"error\", (error: Error) => this._onSocketError(error));\n\t}\n\n\tprivate _onSocketConnection(socket: WebSocket, req: IncomingMessage): void {\n\t\t// An unhandled socket error might crash the server. Handle it first.\n\t\tsocket.on(\"error\", (error) => this._onSocketError(error));\n\n\t\tconst { query = {} } = url.parse(req.url ?? \"\", true);\n\n\t\tconst { id, token, key }: IAuthParams = query;\n\n\t\tif (!id || !token || !key) {\n\t\t\treturn this._sendErrorAndClose(socket, Errors.INVALID_WS_PARAMETERS);\n\t\t}\n\n\t\tif (key !== this.config.key) {\n\t\t\treturn this._sendErrorAndClose(socket, Errors.INVALID_KEY);\n\t\t}\n\n\t\tconst client = this.realm.getClientById(id);\n\n\t\tif (client) {\n\t\t\tif (token !== client.getToken()) {\n\t\t\t\t// ID-taken, invalid token\n\t\t\t\tsocket.send(\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\ttype: MessageType.ID_TAKEN,\n\t\t\t\t\t\tpayload: { msg: \"ID is taken\" },\n\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\treturn socket.close();\n\t\t\t}\n\n\t\t\treturn this._configureWS(socket, client);\n\t\t}\n\n\t\tthis._registerClient({ socket, id, token });\n\t}\n\n\tprivate _onSocketError(error: Error): void {\n\t\t// handle error\n\t\tthis.emit(\"error\", error);\n\t}\n\n\tprivate _registerClient({\n\t\tsocket,\n\t\tid,\n\t\ttoken,\n\t}: {\n\t\tsocket: WebSocket;\n\t\tid: string;\n\t\ttoken: string;\n\t}): void {\n\t\t// Check concurrent limit\n\t\tconst clientsCount = this.realm.getClientsIds().length;\n\n\t\tif (clientsCount >= this.config.concurrent_limit) {\n\t\t\treturn this._sendErrorAndClose(socket, Errors.CONNECTION_LIMIT_EXCEED);\n\t\t}\n\n\t\tconst newClient: IClient = new Client({ id, token });\n\t\tthis.realm.setClient(newClient, id);\n\t\tsocket.send(JSON.stringify({ type: MessageType.OPEN }));\n\n\t\tthis._configureWS(socket, newClient);\n\t}\n\n\tprivate _configureWS(socket: WebSocket, client: IClient): void {\n\t\tclient.setSocket(socket);\n\n\t\t// Cleanup after a socket closes.\n\t\tsocket.on(\"close\", () => {\n\t\t\tif (client.getSocket() === socket) {\n\t\t\t\tthis.realm.removeClientById(client.getId());\n\t\t\t\tthis.emit(\"close\", client);\n\t\t\t}\n\t\t});\n\n\t\t// Handle messages from peers.\n\t\tsocket.on(\"message\", (data) => {\n\t\t\ttry {\n\t\t\t\tconst message = JSON.parse(data.toString());\n\n\t\t\t\tmessage.src = client.getId();\n\n\t\t\t\tthis.emit(\"message\", client, message);\n\t\t\t} catch (e) {\n\t\t\t\tthis.emit(\"error\", e);\n\t\t\t}\n\t\t});\n\n\t\tthis.emit(\"connection\", client);\n\t}\n\n\tprivate _sendErrorAndClose(socket: WebSocket, msg: Errors): void {\n\t\tsocket.send(\n\t\t\tJSON.stringify({\n\t\t\t\ttype: MessageType.ERROR,\n\t\t\t\tpayload: { msg },\n\t\t\t}),\n\t\t);\n\n\t\tsocket.close();\n\t}\n}\n","import type { IClient } from \"../../../models/client\";\n\nexport const HeartbeatHandler = (client: IClient | undefined): boolean => {\n\tif (client) {\n\t\tconst nowTime = new Date().getTime();\n\t\tclient.setLastPing(nowTime);\n\t}\n\n\treturn true;\n};\n","import { MessageType } from \"../../../enums\";\nimport type { IClient } from \"../../../models/client\";\nimport type { IMessage } from \"../../../models/message\";\nimport type { IRealm } from \"../../../models/realm\";\n\nexport const TransmissionHandler = ({\n\trealm,\n}: {\n\trealm: IRealm;\n}): ((client: IClient | undefined, message: IMessage) => boolean) => {\n\tconst handle = (client: IClient | undefined, message: IMessage) => {\n\t\tconst type = message.type;\n\t\tconst srcId = message.src;\n\t\tconst dstId = message.dst;\n\n\t\tconst destinationClient = realm.getClientById(dstId);\n\n\t\t// User is connected!\n\t\tif (destinationClient) {\n\t\t\tconst socket = destinationClient.getSocket();\n\t\t\ttry {\n\t\t\t\tif (socket) {\n\t\t\t\t\tconst data = JSON.stringify(message);\n\n\t\t\t\t\tsocket.send(data);\n\t\t\t\t} else {\n\t\t\t\t\t// Neither socket no res available. Peer dead?\n\t\t\t\t\tthrow new Error(\"Peer dead\");\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// This happens when a peer disconnects without closing connections and\n\t\t\t\t// the associated WebSocket has not closed.\n\t\t\t\t// Tell other side to stop trying.\n\t\t\t\tif (socket) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t} else {\n\t\t\t\t\trealm.removeClientById(destinationClient.getId());\n\t\t\t\t}\n\n\t\t\t\thandle(client, {\n\t\t\t\t\ttype: MessageType.LEAVE,\n\t\t\t\t\tsrc: dstId,\n\t\t\t\t\tdst: srcId,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// Wait for this client to connect/reconnect (XHR) for important\n\t\t\t// messages.\n\t\t\tconst ignoredTypes = [MessageType.LEAVE, MessageType.EXPIRE];\n\n\t\t\tif (!ignoredTypes.includes(type) && dstId) {\n\t\t\t\trealm.addMessageToQueue(dstId, message);\n\t\t\t} else if (type === MessageType.LEAVE && !dstId) {\n\t\t\t\trealm.removeClientById(srcId);\n\t\t\t} else {\n\t\t\t\t// Unavailable destination specified with message LEAVE or EXPIRE\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\n\treturn handle;\n};\n","import type { MessageType } from \"../enums\";\nimport type { IClient } from \"../models/client\";\nimport type { IMessage } from \"../models/message\";\nimport type { Handler } from \"./handler\";\n\nexport interface IHandlersRegistry {\n\tregisterHandler(messageType: MessageType, handler: Handler): void;\n\thandle(client: IClient | undefined, message: IMessage): boolean;\n}\n\nexport class HandlersRegistry implements IHandlersRegistry {\n\tprivate readonly handlers: Map<MessageType, Handler> = new Map();\n\n\tpublic registerHandler(messageType: MessageType, handler: Handler): void {\n\t\tif (this.handlers.has(messageType)) return;\n\n\t\tthis.handlers.set(messageType, handler);\n\t}\n\n\tpublic handle(client: IClient | undefined, message: IMessage): boolean {\n\t\tconst { type } = message;\n\n\t\tconst handler = this.handlers.get(type);\n\n\t\tif (!handler) return false;\n\n\t\treturn handler(client, message);\n\t}\n}\n","import { MessageType } from \"../enums\";\nimport { HeartbeatHandler, TransmissionHandler } from \"./handlers\";\nimport type { IHandlersRegistry } from \"./handlersRegistry\";\nimport { HandlersRegistry } from \"./handlersRegistry\";\nimport type { IClient } from \"../models/client\";\nimport type { IMessage } from \"../models/message\";\nimport type { IRealm } from \"../models/realm\";\nimport type { Handler } from \"./handler\";\n\nexport interface IMessageHandler {\n\thandle(client: IClient | undefined, message: IMessage): boolean;\n}\n\nexport class MessageHandler implements IMessageHandler {\n\tconstructor(\n\t\trealm: IRealm,\n\t\tprivate readonly handlersRegistry: IHandlersRegistry = new HandlersRegistry(),\n\t) {\n\t\tconst transmissionHandler: Handler = TransmissionHandler({ realm });\n\t\tconst heartbeatHandler: Handler = HeartbeatHandler;\n\n\t\tconst handleTransmission: Handler = (\n\t\t\tclient: IClient | undefined,\n\t\t\t{ type, src, dst, payload }: IMessage,\n\t\t): boolean => {\n\t\t\treturn transmissionHandler(client, {\n\t\t\t\ttype,\n\t\t\t\tsrc,\n\t\t\t\tdst,\n\t\t\t\tpayload,\n\t\t\t});\n\t\t};\n\n\t\tconst handleHeartbeat = (client: IClient | undefined, message: IMessage) =>\n\t\t\theartbeatHandler(client, message);\n\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.HEARTBEAT,\n\t\t\thandleHeartbeat,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.OFFER,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.ANSWER,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.CANDIDATE,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.LEAVE,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.EXPIRE,\n\t\t\thandleTransmission,\n\t\t);\n\t}\n\n\tpublic handle(client: IClient | undefined, message: IMessage): boolean {\n\t\treturn this.handlersRegistry.handle(client, message);\n\t}\n}\n","{\n\t\"name\": \"PeerJS Server\",\n\t\"description\": \"A server side element to broker connections between PeerJS clients.\",\n\t\"website\": \"https://peerjs.com/\"\n}\n","import express from \"express\";\nimport type { IConfig } from \"../../../config\";\nimport type { IRealm } from \"../../../models/realm\";\n\nexport default ({\n\tconfig,\n\trealm,\n}: {\n\tconfig: IConfig;\n\trealm: IRealm;\n}): express.Router => {\n\tconst app = express.Router();\n\n\t// Retrieve guaranteed random ID.\n\tapp.get(\"/id\", (_, res: express.Response) => {\n\t\tres.contentType(\"html\");\n\t\tres.send(realm.generateClientId(config.generateClientId));\n\t});\n\n\t// Get a list of all peers for a key, enabled by the `allowDiscovery` flag.\n\tapp.get(\"/peers\", (_, res: express.Response) => {\n\t\tif (config.allow_discovery) {\n\t\t\tconst clientsIds = realm.getClientsIds();\n\n\t\t\treturn res.send(clientsIds);\n\t\t}\n\n\t\treturn res.sendStatus(401);\n\t});\n\n\treturn app;\n};\n","import cors, { CorsOptions } from \"cors\";\nimport express from \"express\";\nimport publicContent from \"../../app.json\";\nimport PublicApi from \"./v1/public\";\nimport type { IConfig } from \"../config\";\nimport type { IRealm } from \"../models/realm\";\n\nexport const Api = ({\n\tconfig,\n\trealm,\n\tcorsOptions,\n}: {\n\tconfig: IConfig;\n\trealm: IRealm;\n\tcorsOptions: CorsOptions;\n}): express.Router => {\n\tconst app = express.Router();\n\n\tapp.use(cors(corsOptions));\n\n\tapp.get(\"/\", (_, res) => {\n\t\tres.send(publicContent);\n\t});\n\n\tapp.use(\"/:key\", PublicApi({ config, realm }));\n\n\treturn app;\n};\n","import type express from \"express\";\nimport type { Server as HttpServer } from \"node:http\";\nimport type { Server as HttpsServer } from \"node:https\";\nimport path from \"node:path\";\nimport type { IRealm } from \"./models/realm\";\nimport { Realm } from \"./models/realm\";\nimport { CheckBrokenConnections } from \"./services/checkBrokenConnections\";\nimport type { IMessagesExpire } from \"./services/messagesExpire\";\nimport { MessagesExpire } from \"./services/messagesExpire\";\nimport type { IWebSocketServer } from \"./services/webSocketServer\";\nimport { WebSocketServer } from \"./services/webSocketServer\";\nimport { MessageHandler } from \"./messageHandler\";\nimport { Api } from \"./api\";\nimport type { IClient } from \"./models/client\";\nimport type { IMessage } from \"./models/message\";\nimport type { IConfig } from \"./config\";\n\nexport interface PeerServerEvents {\n\ton(event: \"connection\", listener: (client: IClient) => void): this;\n\ton(\n\t\tevent: \"message\",\n\t\tlistener: (client: IClient, message: IMessage) => void,\n\t): this;\n\ton(event: \"disconnect\", listener: (client: IClient) => void): this;\n\ton(event: \"error\", listener: (client: Error) => void): this;\n}\n\nexport const createInstance = ({\n\tapp,\n\tserver,\n\toptions,\n}: {\n\tapp: express.Application;\n\tserver: HttpServer | HttpsServer;\n\toptions: IConfig;\n}): void => {\n\tconst config = options;\n\tconst realm: IRealm = new Realm();\n\tconst messageHandler = new MessageHandler(realm);\n\n\tconst api = Api({ config, realm, corsOptions: options.corsOptions });\n\tconst messagesExpire: IMessagesExpire = new MessagesExpire({\n\t\trealm,\n\t\tconfig,\n\t\tmessageHandler,\n\t});\n\tconst checkBrokenConnections = new CheckBrokenConnections({\n\t\trealm,\n\t\tconfig,\n\t\tonClose: (client) => {\n\t\t\tapp.emit(\"disconnect\", client);\n\t\t},\n\t});\n\n\tapp.use(options.path, api);\n\n\t//use mountpath for WS server\n\tconst customConfig = {\n\t\t...config,\n\t\tpath: path.posix.join(app.path(), options.path, \"/\"),\n\t};\n\n\tconst wss: IWebSocketServer = new WebSocketServer({\n\t\tserver,\n\t\trealm,\n\t\tconfig: customConfig,\n\t});\n\n\twss.on(\"connection\", (client: IClient) => {\n\t\tconst messageQueue = realm.getMessageQueueById(client.getId());\n\n\t\tif (messageQueue) {\n\t\t\tlet message: IMessage | undefined;\n\n\t\t\twhile ((message = messageQueue.readMessage())) {\n\t\t\t\tmessageHandler.handle(client, message);\n\t\t\t}\n\t\t\trealm.clearMessageQueue(client.getId());\n\t\t}\n\n\t\tapp.emit(\"connection\", client);\n\t});\n\n\twss.on(\"message\", (client: IClient, message: IMessage) => {\n\t\tapp.emit(\"message\", client, message);\n\t\tmessageHandler.handle(client, message);\n\t});\n\n\twss.on(\"close\", (client: IClient) => {\n\t\tapp.emit(\"disconnect\", client);\n\t});\n\n\twss.on(\"error\", (error: Error) => {\n\t\tapp.emit(\"error\", error);\n\t});\n\n\tmessagesExpire.startMessagesExpiration();\n\tcheckBrokenConnections.start();\n};\n","#!/usr/bin/env node\n\nimport path from \"node:path\";\nimport { version } from \"../package.json\";\nimport fs from \"node:fs\";\nconst optimistUsageLength = 98;\nimport yargs from \"yargs\";\nimport { hideBin } from \"yargs/helpers\";\nimport { PeerServer } from \"../src\";\nimport type { AddressInfo } from \"node:net\";\nimport type { CorsOptions } from \"cors\";\n\nconst y = yargs(hideBin(process.argv));\n\nconst portEnvIsSet = !!process.env[\"PORT\"];\n\nconst opts = y\n\t.usage(\"Usage: $0\")\n\t.wrap(Math.min(optimistUsageLength, y.terminalWidth()))\n\t.options({\n\t\texpire_timeout: {\n\t\t\tdemandOption: false,\n\t\t\talias: \"t\",\n\t\t\tdescribe: \"timeout (milliseconds)\",\n\t\t\tdefault: 5000,\n\t\t},\n\t\tconcurrent_limit: {\n\t\t\tdemandOption: false,\n\t\t\talias: \"c\",\n\t\t\tdescribe: \"concurrent limit\",\n\t\t\tdefault: 5000,\n\t\t},\n\t\talive_timeout: {\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"broken connection check timeout (milliseconds)\",\n\t\t\tdefault: 60000,\n\t\t},\n\t\tkey: {\n\t\t\tdemandOption: false,\n\t\t\talias: \"k\",\n\t\t\tdescribe: \"connection key\",\n\t\t\tdefault: \"peerjs\",\n\t\t},\n\t\tsslkey: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"path to SSL key\",\n\t\t},\n\t\tsslcert: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"path to SSL certificate\",\n\t\t},\n\t\thost: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\talias: \"H\",\n\t\t\tdescribe: \"host\",\n\t\t},\n\t\tport: {\n\t\t\ttype: \"number\",\n\t\t\tdemandOption: !portEnvIsSet,\n\t\t\talias: \"p\",\n\t\t\tdescribe: \"port\",\n\t\t},\n\t\tpath: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"custom path\",\n\t\t\tdefault: process.env[\"PEERSERVER_PATH\"] || \"/\",\n\t\t},\n\t\tallow_discovery: {\n\t\t\ttype: \"boolean\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"allow discovery of peers\",\n\t\t},\n\t\tproxied: {\n\t\t\ttype: \"boolean\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"Set true if PeerServer stays behind a reverse proxy\",\n\t\t\tdefault: false,\n\t\t},\n\t\tcors: {\n\t\t\ttype: \"string\",\n\t\t\tarray: true,\n\t\t\tdescribe: \"Set the list of CORS origins\",\n\t\t},\n\t})\n\t.boolean(\"allow_discovery\")\n\t.parseSync();\n\nif (!opts.port) {\n\topts.port = parseInt(process.env[\"PORT\"] as string);\n}\nif (opts.cors) {\n\topts[\"corsOptions\"] = {\n\t\torigin: opts.cors,\n\t} satisfies CorsOptions;\n}\nprocess.on(\"uncaughtException\", function (e) {\n\tconsole.error(\"Error: \" + e);\n});\n\nif (opts.sslkey || opts.sslcert) {\n\tif (opts.sslkey && opts.sslcert) {\n\t\topts[\"ssl\"] = {\n\t\t\tkey: fs.readFileSync(path.resolve(opts.sslkey)),\n\t\t\tcert: fs.readFileSync(path.resolve(opts.sslcert)),\n\t\t};\n\t} else {\n\t\tconsole.error(\n\t\t\t\"Warning: PeerServer will not run because either \" +\n\t\t\t\t\"the key or the certificate has not been provided.\",\n\t\t);\n\t\tprocess.exit(1);\n\t}\n}\n\nconst userPath = opts.path;\nconst server = PeerServer(opts, (server) => {\n\tconst { address: host, port } = server.address() as AddressInfo;\n\n\tconsole.log(\n\t\t\"Started PeerServer on %s, port: %s, path: %s (v. %s)\",\n\t\thost,\n\t\tport,\n\t\tuserPath || \"/\",\n\t\tversion,\n\t);\n\n\tconst shutdownApp = () => {\n\t\tserver.close(() => {\n\t\t\tconsole.log(\"Http server closed.\");\n\n\t\t\tprocess.exit(0);\n\t\t});\n\t};\n\n\tprocess.on(\"SIGINT\", shutdownApp);\n\tprocess.on(\"SIGTERM\", shutdownApp);\n});\n\nserver.on(\"connection\", (client) => {\n\tconsole.log(`Client connected: ${client.getId()}`);\n});\n\nserver.on(\"disconnect\", (client) => {\n\tconsole.log(`Client disconnected: ${client.getId()}`);\n});\n","import express, { type Express } from \"express\";\nimport http from \"node:http\";\nimport https from \"node:https\";\n\nimport type { IConfig } from \"./config\";\nimport defaultConfig from \"./config\";\nimport type { PeerServerEvents } from \"./instance\";\nimport { createInstance } from \"./instance\";\nimport type { IClient } from \"./models/client\";\nimport type { IMessage } from \"./models/message\";\n\nexport type { MessageType } from \"./enums\";\nexport type { IConfig, PeerServerEvents, IClient, IMessage };\n\nfunction ExpressPeerServer(\n\tserver: https.Server | http.Server,\n\toptions?: Partial<IConfig>,\n) {\n\tconst app = express();\n\n\tconst newOptions: IConfig = {\n\t\t...defaultConfig,\n\t\t...options,\n\t};\n\n\tif (newOptions.proxied) {\n\t\tapp.set(\n\t\t\t\"trust proxy\",\n\t\t\tnewOptions.proxied === \"false\" ? false : !!newOptions.proxied,\n\t\t);\n\t}\n\n\tapp.on(\"mount\", () => {\n\t\tif (!server) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Server is not passed to constructor - \" + \"can't start PeerServer\",\n\t\t\t);\n\t\t}\n\n\t\tcreateInstance({ app, server, options: newOptions });\n\t});\n\n\treturn app as Express & PeerServerEvents;\n}\n\nfunction PeerServer(\n\toptions: Partial<IConfig> = {},\n\tcallback?: (server: https.Server | http.Server) => void,\n) {\n\tconst app = express();\n\n\tlet newOptions: IConfig = {\n\t\t...defaultConfig,\n\t\t...options,\n\t};\n\n\tconst port = newOptions.port;\n\tconst host = newOptions.host;\n\n\tlet server: https.Server | http.Server;\n\n\tconst { ssl, ...restOptions } = newOptions;\n\tif (ssl && Object.keys(ssl).length) {\n\t\tserver = https.createServer(ssl, app);\n\n\t\tnewOptions = restOptions;\n\t} else {\n\t\tserver = http.createServer(app);\n\t}\n\n\tconst peerjs = ExpressPeerServer(server, newOptions);\n\tapp.use(peerjs);\n\n\tserver.listen(port, host, () => callback?.(server));\n\n\treturn peerjs;\n}\n\nexport { ExpressPeerServer, PeerServer };\n"],"names":["$26afa55b21e869a1$exports","JSON","parse","$aeb1147dec1b7a02$export$2e2bcd8739ae039","host","port","expire_timeout","alive_timeout","key","path","concurrent_limit","allow_discovery","proxied","cleanup_out_msgs","corsOptions","origin","$2c42eaf0ccc66758$export$eb4c623330d4cbcc","lastReadAt","Date","getTime","messages","getLastReadAt","this","addMessage","message","push","readMessage","length","shift","getMessages","$0a339ca52e0451c9$export$3ee29d34e33d9116","clients","Map","messageQueues","getClientsIds","keys","getClientById","clientId","get","getClientsIdsWithQueue","setClient","client","id","set","removeClientById","delete","getMessageQueueById","addMessageToQueue","clearMessageQueue","generateClientId","generateId","$7BbP7$randomUUID","$6840aafc61c9abd6$export$6fa53df6b5b88df7","timeoutId","constructor","realm","config","checkInterval","onClose","start","clearTimeout","setTimeout","checkConnections","stop","clientsIds","now","aliveTimeout","getLastPing","getSocket","close","setSocket","$d461d7260b6fc353$export$b8e9cd941e8016ac","Errors","$d461d7260b6fc353$export$80edbf15fa61a4db","MessageType","$c97baf9b78981954$export$a13b411d0e88b1af","messageHandler","startMessagesExpiration","pruneOutstanding","stopMessagesExpiration","destinationClientsIds","maxDiff","seen","destinationClientId","messageQueue","seenKey","src","dst","handle","undefined","type","EXPIRE","$d09fcb6ab78a3f48$export$1f2bb630327ac4b6","socket","lastPing","token","getId","getToken","setLastPing","send","data","stringify","$4ae24f8b3b7cf7b0$export$f47674b57e51ee3b","$7BbP7$EventEmitter","server","super","setMaxListeners","endsWith","options","socketServer","createWebSocketServer","$7BbP7$WebSocketServer","on","req","_onSocketConnection","error","_onSocketError","query","$7BbP7$nodeurl","url","_sendErrorAndClose","INVALID_WS_PARAMETERS","INVALID_KEY","ID_TAKEN","payload","msg","_configureWS","_registerClient","emit","CONNECTION_LIMIT_EXCEED","newClient","OPEN","toString","e","ERROR","$c523c19e3fc944a1$export$65302b915833a46d","nowTime","$879e80f95ec634eb$export$809c011ea942310","srcId","dstId","destinationClient","Error","LEAVE","includes","$df0509eaca4ae82c$export$cfe4a96645b0bbcf","handlers","registerHandler","messageType","handler","has","$3089a9bad51bbb04$export$3deceafe0aaeaa95","handlersRegistry","transmissionHandler","heartbeatHandler","handleTransmission","HEARTBEAT","OFFER","ANSWER","CANDIDATE","$264fdbd7932d14df$exports","$6910ff2a5db5006f$export$2e2bcd8739ae039","app","$7BbP7$express","Router","_","res","contentType","sendStatus","$69f9994c6ebd6802$export$bf71da7aebe9ddc1","use","$7BbP7$cors","$parcel$interopDefault","$e7d4fd16baa81890$export$99152e8d49ca4e7d","api","messagesExpire","checkBrokenConnections","customConfig","$7BbP7$nodepath","posix","join","wss","$3809f3d53201df9f$var$y","$7BbP7$yargs","$7BbP7$hideBin","process","argv","$3809f3d53201df9f$var$portEnvIsSet","env","$3809f3d53201df9f$var$opts","usage","wrap","Math","min","terminalWidth","demandOption","alias","describe","default","sslkey","sslcert","cors","array","boolean","parseSync","parseInt","console","$7BbP7$nodefs","readFileSync","resolve","cert","exit","$3809f3d53201df9f$var$userPath","$3809f3d53201df9f$var$server","callback","newOptions","ssl","restOptions","Object","$7BbP7$nodehttps","createServer","$7BbP7$nodehttp","peerjs","$0fe9c43b5c368182$export$8c57434a18c696c9","listen","address","log","version","shutdownApp"],"version":3,"file":"peerjs.js.map","sourceRoot":"../../"}